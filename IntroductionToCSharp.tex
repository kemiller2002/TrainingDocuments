\documentclass {amsart}

\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}
\usepackage{verbatim}
\usepackage{hyperref}
\usepackage[T1]{fontenc}



\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

\definecolor{commentgreen}{rgb}{0,0.3,0}

\lstdefinelanguage{CSharp}{
  keywords={try,finally, typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break, int, int?, public, class, string, void, using, static, throw, namespace},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{commentgreen}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{
   language=CSharp,
   backgroundcolor=\color{lightgray},
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
   numbers=left,
   numberstyle=\footnotesize,
   numbersep=9pt,
   tabsize=2,
   breaklines=true,
   showtabs=false,
   captionpos=b
}

\title{Introduction To C\#}


\begin{document}

\maketitle


\section{Setup}
	\subsection{LINQPad}
		\url{http://www.linqpad.net/}
	\subsection{Dot Net Fiddle}
		\url{https://dotnetfiddle.net/}

\section{Data Types}
	\subsection{Value Types}  These are the default value types. 
		\begin{itemize}
			\item bool
			\item byte
			\item char
			\item decimal
			\item double
			\item enum
			\item float
			\item int
			\item long
			\item \emph{sbyte}*
			\item short
			\item struct
			\item \emph{uint}*
			\item \emph{ulong}
			\item \emph{ushort}*
		\end{itemize}
		Anything else that is classified as a struct is also a value type. \linebreak

		\emph{*These types are not CLS compliant, and may cause interoperability issue with other languages.  Unless there is a solid reason, they should avoid being used.} 

		\subsection{Pass By Value}  Value types are not pass by reference in C\#. When passed into a method, they will be copied for use in the method.  Altering their value inside a method will not change the value passed in.

		\begin{lstlisting}
			using System;
								
			public class Program
			{
				public static void Main()
				{
					var theAnswer = 42;

					Console.WriteLine("What the answer is: " + theAnswer);
					
					CantChangeTheAnswer(theAnswer);
					
					Console.WriteLine("What the answer still is: " + theAnswer);
				}
				
				
				public static void CantChangeTheAnswer(int theAnswer)
				{
					theAnswer = -1;
					
					Console.WriteLine("Inside the method: " + theAnswer);
				}
			}
		\end{lstlisting}  

		\begin{verbatim}
			What the answer is: 42
			Inside the method: -1
			What the answer still is: 42
		\end{verbatim}

		\subsubsection{Nullables} Since Value Types can't be null, Microsoft created nullables to stand in their place when they need to be.  They are represetned by int?, bool?, etc. or Nullable\textless int\textgreater \space etc.  In order to use a Nullable you must check to see if the object has a value becore calling the value.  If not, it automatically throw an exception.

		\begin{lstlisting}
			int? checkValue = null;
			if(checkValue.HasValue)
			{
				Console.WriteLine(checkValue.Value);
			}
			else
			{
				Console.WriteLine("No value present");
			}
		\end{lstlisting}

	\subsection{Reference Types}  Classes instantiate objects, and all objects are references types.  Everything can convert to type Object.  All reference types are pass by reference into functions.  Take the following example: 

	\subsection{Readonly Property}  Class level variables (there are no global variables in C \# although class level variables are commonly referred to as such) may be marked as {\bf readonly}.  Once instantiated, the value is bound to that variable and connot be changed.  Any varaible or property defined as readonly must either be defined on initialization or in the class' constructor.
\linebreak

{\bf NOTE:} Properites inside the bound object may still be changed, even though the variable is set to {\bf readonly}.  For example: 

	\begin{lstlisting}
		using System;
		using System.Collections.Generic;

							
		public class Program
		{

			public static void Main()
			{
				var p = new Program();
				p.PutNumbersIn();
				
				Console.WriteLine("Number of numbers: " + p.Numbers.Count);
			}

			
				
			public readonly List<int> Numbers; 


			public Program () 
			{
				Numbers = new List<int>();	
			}

			public void PutNumbersIn () 
			{
				Numbers.Add(1);
				Numbers.Add(2);
				Numbers.Add(3);
			}
			
		}
	\end{lstlisting}

	\begin{verbatim}Number of numbers: 3\end{verbatim}

\section{Functions}
	\subsection{Access Modifiers}
		\begin{itemize}
			\item public 		//Everything can access
			\item internal 	//Same assembly objects can access; can be used with protected
			\item protected	//Child objects can access; can be used with internal
			\item private		//Objects within the same class can access
		\end{itemize}

	\subsection{Static}  Static allows methods and functions to exist outsite of an object context . They are attached to a class, and may not interact with instance variables and methods outside of its scope.  
		\begin{lstlisting}
		using System;

		public class StaticExample 
		{
			public static string Capitalize(string toCapitalize)
			{
				return toCapitalize.ToUpper();
			}
		}

		public class Program
		{
			public static void Main()
			{
				Console.WriteLine(StaticExample.Capitalize("Make me big"));
			}
		}

		\end{lstlisting}

	\section{Generics}
		\subsection{Use}  Pre .Net 2.0, there was no real way of sharing methods and properties accross classes which weren't related.  To have similar implementations of the same method, the code had to be duplicated and customized.  For examle, {\bf string[] } and {\bf int[]} are both collections of objects, but they aren't related in terms of inheritance.  It would be beneificial for each to have methods like Sort and Add, but to iimplement them and not break type safety (\url{http://en.wikipedia.org/wiki/Type_safety}) each method would have to implment it's own version, or the method would have to be generalized to take a common base class type such as {\bf System.Object}.  Generics allow classes and structs to have methods and properties which operate on several different types provied that all types which are allowed in the generic satisify the compile time requirements to have those methods and properites interact with them.  
		\subsection{Syntax}  Generics are specified by the {\bf \textless T\textgreater} next to a type.  For example to create a List of Int: {\bf List\textless int\textgreater}.  


	\section{Lambda Expressions}  These are a shorthand syntax for creating an anonymous function.  When declared in conjuction with use in a function that accepts a function as a parameter (delegate), the compiler will automatically infer the correct types. 
		\begin{lstlisting}
			using System;
			using System.Collections.Generic;
			using System.Linq;
			
			public class Program
			{
				public static void Main()
				{
					var numbers = new List<int>(new [] {-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8});
			
					var positiveNumbersWithLamdba = numbers.Where(x=> x > 0);
			
					var positiveNumber = numbers.Where(IsPositive);
					
					var positiveTotal = positiveNumber.Aggregate<int>(FoldMethod);
			
			
					var positiveTotalWithAgg = positiveNumbersWithLamdba.Aggregate<int>((agg, n)=> agg += n);
			
					
					Console.WriteLine(positiveTotal);
					
					Console.WriteLine(positiveTotalWithAgg);
					
				}
			
				private static bool IsPositive (int number)
				{
					return number > 0;
				}
				
				public static int FoldMethod (int accumulator, int number){
					return accumulator + number;	
				}
				
			}
		\end{lstlisting}


	\subsection{Func\textless  T\textgreater, Action\textless  T\textgreater, and Predicate\textless  T, bool\textgreater} These are the types behind anonymous methods. 
 {\bf Action \textless  T\textgreater} \space takes at least one argument, and returns nothing. {\bf Func\textless  T\textgreater} always returns something.  {\bf Predicate\textless  T, bool\textgreater} always takes  parameter and returns a bool. 

	\begin{lstlisting}
			using System;
			using System.Collections.Generic;
			using System.Linq;
			
			public class Program
			{
				public static void Main()
				{
					var numbers = new List<int>(new [] {-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8});
			
					var negativeNumbersFilter = new Func<int,bool>(x=> x < 0);
			
					var negativeNumbers = numbers.Where(negativeNumbersFilter);
			
					var negativeNumbersAggregated = negativeNumbers.Aggregate<int>((agg, n)=> agg += n);
			
					Console.WriteLine(negativeNumbersAggregated);
					
				}
			}
	\end{lstlisting}



\section{Classes}
	\subsection{Basic Definition}
	\subsection{Inheritance}
		\subsubsection{Abstract}
		\subsubsection{Virtual}
	\subsection{Polymorphism}
		\subsubsection{Method Overloading}
\section{Structs}
	\subsection{Basic Definition}
	

\section{Namespaces}
	\subsection{Description} Everything in .NET has a name space.  If no namspace expllicitely named for an object, it is given the global namespace for the program.  Namespaces are used to keep classes with the same name from colliding.  Visual Studio will automatically create namespace for each class based on the application name and the folder structure. 

		\begin{lstlisting}
			namespace Pan.TechnicalSolutions.Bonzai
			{
				//everything in this scope will have the same namespace.  
			}
		\end{lstlisting}

	\subsection {Using}
		\subsubsection {Importing}  In order to use an object in C\#.NET, either the object must be referred to by its full name (example String is System.String), or the namespace must be imported with the {\bf using} keyword.  
		

\section{Interfaces}
	\subsection{Syntax} The basic syntax is as follows: 
		\begin{verbatim}
			public interface <Interface-Name> {
				     <Return-Type> <Method-Name> (<Parameter>);
				     <Return-Type> <Property-Name> {get; set;}
				     <Return-Type> <Property-Name> {get; }
				     <Return-Type> <Property-Name> {set;}

				     <Return-Type> <Variable-Name>;
			}
		\end{verbatim} 
	\subsection{Example}  The following shows and interface and class implementation.  All methods and properties in an interface must be public. 

	\begin{lstlisting}
		public interface INumbers
		{
			int Add(int numberOne, int numberTwo);

			int Subtract(int numberOne, int numberTwo);
		}

		public class Number : INumbers
		{
			int Add(int numberOne, int numberTwo){return numberOne + numberTwo;}

			int Subtract(int numberOne, int numberTwo){return numberOne - numberTwo;}
		}

	\end{lstlisting}


	\subsection{IEnumerable\textless T\textgreater}  Almost everything in .NET which has a collection that can be iteterated over implements {\bf IEnumerable\textless T\textgreater}.  If a method returns a collection or accepts one and the intention is not to modifiy them, {\bf IEnumerable\textless T\textgreater} should be the type.  Qualifying the type to be something concrete like {\bf List\textless T\textgreater} forces the collection to initialize into an object and hold it in memory.  {\bf IEnumerable\textless T\textgreater} forces only the current item in the iteration to exist in memory thereby reducing load on the system.  



		\subsubsection {yield}  This allows enumerations to be created only the fly, and continue creation until the end condition is satisfied.

		\begin{lstlisting}
			using System;
			using System.Collections.Generic;
			using System.Linq;

			public class Program
			{
				public static void Main()
				{
					foreach(var p in GetPrimeNumbers(5)){
						Console.WriteLine(p);	
					}
				}
				
				
				public static IEnumerable<int> GetPrimeNumbers (int numberToGet)
				{
					var count = 0;
					var currentNumber = 2;
					var primes = new List<int> (numberToGet); 

					var isPrime = new Func<int,bool> (numberToCheck => {
						var stoppingPoint = (int) Math.Sqrt(numberToCheck);
						return !primes
							.Where(y => y <= stoppingPoint)
							.Any(y => numberToCheck % y == 0);}
						); 		
					
					
					while(count < numberToGet)
					{
						if(isPrime(currentNumber))
						{
							yield return currentNumber;
							primes.Add(currentNumber);
							count ++;		   
						}
						
						currentNumber ++;
					}
				}
				
			}

		\end{lstlisting}
		\begin{verbatim}
			2
			3
			5
			7
			11
		\end{verbatim}

\section{Unmanaged Resources}

\section{LINQ}

\section{Error Handling}
	\subsection{Syntax}  C\# uses the try/catch/finally pattern.
		\begin{lstlisting}
			try{}
			catch (Exception Variable){}
			finally{}
		\end{lstlisting}
	Both {\bf catch} and {\bf finally} are optional, but one of them must exist.  The {\bf finally} block will always execute, even if there is an exception in the {\bf try} block, and if there is no {\bf catch} block, the exception will be thrown once the {\bf finally} block finishes executing.  The {\bf catch} block will only execute if an exception occurs, and the exception will not bubble up the call stack unless rethrown.  
		
	Multiple catches blocks can exist to catch different types of exceptions.  The listing must go from most specific to most general to catch the diffenerent exception types. 

	\begin{lstlisting}
		catch{Exception ex)
		{
			//Because it's first, all exceptions will get caught here.
		}
		catch{IOException ioEx)
		{
			//will never enter this block. 
		}
	\end{lstlisting}
	
	Correct catch ordering:

	\begin{lstlisting}
		catch{IOException ioEx)
		{
			//IOException will get caught here
		}
		catch{Exception ex)
		{
			//all other exceptions will get caught here.
		}
	\end{lstlisting}
	\subsection{Throw}  In order to rethrow and exception, use the {\bf throw} keyword.  
		\begin{lstlisting}
			catch(Exception ex)
			{
				throw;
			}
		\end{lstlisting}
	{\bf NOTE:} Using {\bf throw ex;} will reset the stack trace, and the original place where the exception ocurred will be losg.
		\begin{lstlisting}
			catch(Exception ex)
			{
				throw ex;  //STACK TRACE LOST.
			}
		\end{lstlisting}
		

\section{Creating Unit Tests}


\end{document}
