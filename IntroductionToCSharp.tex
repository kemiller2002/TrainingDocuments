\documentclass {amsart}

\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}
\usepackage{verbatim}
\usepackage{hyperref}


\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}



\lstdefinelanguage{CSharp}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{
   language=CSharp,
   %backgroundcolor=\color{lightgray},
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
  % numbers=left,
   numberstyle=\footnotesize,
   numbersep=9pt,
   tabsize=2,
   breaklines=true,
   showtabs=false,
   captionpos=b
}

\title{Introduction To C\#}


\begin{document}

\maketitle


\section{Setup}
	\subsection{LINQPad}
		\url{http://www.linqpad.net/}

\section{Data Types}
	\subsection{Value Types}  These are the default value types. 
		\begin{itemize}
			\item bool
			\item byte
			\item char
			\item decimal
			\item double
			\item enum
			\item float
			\item int
			\item long
			\item sbyte
			\item short
			\item struct
			\item uint
			\item ulong
			\item ushort
		\end{itemize}

		Anything else that is classified as a struct is also a value type. 

		\subsubsection{Nullables} Since Value Types can't be null, Microsoft created nullables to stand in their place when they need to be.  They are represetned by int?, bool?, etc. or Nullable(int) etc.  
	\subsection{Reference Types}  Classes instantiate objects, and all objects are references types.  Everything can convert to type Object.  All reference types are pass by reference into functions.  Take the following example: 

	\subsection{Readonly Property}

\section{Functions}
	\subsection{Access Modifiers}
		\begin{itemize}
			\item public 		//Everything can access
			\item internal 	//Same assembly objects can access; can be used with protected
			\item protected	//Child objects can access; can be used with internal
			\item private		//Objects within the same class can access
		\end{itemize}

	\subsection{Static}
	\subsection{Lamda Expressions}
	\subsection{Func and Action}


\section{Classes}
	\subsection{Basic Definition}
	\subsection{Inheritance}
		\subsubsection{Abstract}
		\subsubsection{Virtual}
	\subsection{Polymorphism}
		\subsubsection{Method Overloading}
\section{Structs}
	\subsection{Basic Definition}
	

\section{Namespaces}
	\subsection {Using}
\section{Interfaces}
	\subsection{Syntax} The basic syntax is as follows: 
		\begin{verbatim}
			public interface <Interface-Name> {
				     <Return-Type> <Method-Name> (<Parameter>);
				     <Return-Type> <Property-Name> {get; set;}
				     <Return-Type> <Property-Name> {get; }
				     <Return-Type> <Property-Name> {set;}

				     <Return-Type> <Variable-Name>;
			}
		\end{verbatim}
	\subsection{IEnumerable}
		\subsubsection {yield}


\section{Generics}

\section{Unmanaged Resources}

\section{LINQ}

\section{Error Handling}

\section{Creating Unit Tests}


\end{document}
