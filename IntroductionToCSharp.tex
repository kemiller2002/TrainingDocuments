\documentclass {amsart}

\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}
\usepackage{verbatim}
\usepackage{hyperref}
\usepackage[T1]{fontenc}



\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}



\lstdefinelanguage{CSharp}{
  keywords={try,finally, typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break, int, int?, public, class, string, void, using},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{
   language=CSharp,
   %backgroundcolor=\color{lightgray},
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
  % numbers=left,
   numberstyle=\footnotesize,
   numbersep=9pt,
   tabsize=2,
   breaklines=true,
   showtabs=false,
   captionpos=b
}

\title{Introduction To C\#}


\begin{document}

\maketitle


\section{Setup}
	\subsection{LINQPad}
		\url{http://www.linqpad.net/}

\section{Data Types}
	\subsection{Value Types}  These are the default value types. 
		\begin{itemize}
			\item bool
			\item byte
			\item char
			\item decimal
			\item double
			\item enum
			\item float
			\item int
			\item long
			\item \emph{sbyte}*
			\item short
			\item struct
			\item \emph{uint}*
			\item \emph{ulong}
			\item \emph{ushort}*
		\end{itemize}
		Anything else that is classified as a struct is also a value type. \vspace{.5cm}  Value types are not pass by reference in C\#.  When passed into a method, they will be copied for use in the method.  Altering their value inside a method will not change the value passed in.

		\begin{lstlisting}

			


		\end{lstlisting}  

		\emph{*These types are not CLS compliant, and may cause interoperability issue with other languages.  Unless there is a solid reason, they should avoid being used.} 


		\subsubsection{Nullables} Since Value Types can't be null, Microsoft created nullables to stand in their place when they need to be.  They are represetned by int?, bool?, etc. or Nullable(int) etc.  In order to use a Nullable you must check to see if the object has a value becore calling the value.  If not, it automatically throw an exception.

		\begin{lstlisting}
			int? checkValue = null;
			if(checkValue.HasValue)
			{
				Console.WriteLine(checkValue.Value);
			}
			else
			{
				Console.WriteLine("No value present");
			}
		\end{lstlisting}

	\subsection{Reference Types}  Classes instantiate objects, and all objects are references types.  Everything can convert to type Object.  All reference types are pass by reference into functions.  Take the following example: 

	\subsection{Readonly Property}

\section{Functions}
	\subsection{Access Modifiers}
		\begin{itemize}
			\item public 		//Everything can access
			\item internal 	//Same assembly objects can access; can be used with protected
			\item protected	//Child objects can access; can be used with internal
			\item private		//Objects within the same class can access
		\end{itemize}

	\subsection{Static}  Static allows methods and functions to exist outsite of an object context . They are attached to a class, and may not interact with instance variables and methods outside of its scope.  
		\begin{lstlisting}

		using System;

		public class StaticExample 
		{
			public static string Capitalize(string toCapitalize)
			{
				return toCapitalize.ToUpper();
			}
		}

		public class Program
		{
			public static void Main()
			{
				Console.WriteLine(StaticExample.Capitalize("Make me big"));
			}
		}

		\end{lstlisting}

	\section{Generics}
		\subsection{Use}  Pre .Net 2.0, there was no real way of sharing methods and properties accross classes which weren't related.  To have similar implementations of the same method, the code had to be duplicated and customized.  For examle, {\bf string[] } and {\bf int[]} are both collections of objects, but they aren't related in terms of inheritance.  It would be beneificial for each to have methods like Sort and Add, but to iimplement them and not break type safety (\url{http://en.wikipedia.org/wiki/Type_safety}) each method would have to implment it's own version, or the method would have to be generalized to take a common base class type such as {\bf System.Object}.  Generics allow classes and structs to have methods and properties which operate on several different types provied that all types which are allowed in the generic satisify the compile time requirements to have those methods and properites interact with them.  
		\subsection{Syntax}  Generics are specified by the {\bf \textless T\textgreater} next to a type.  For example to create a List of Int: {\bf List\textless int\textgreater}.  


	\section{Lambda Expressions}  These are a shorthand syntax for creating an anonymous function.  When declared in conjuction with use in a function that accepts a function as a parameter (delegate), the compiler will automatically infer the correct types. 
		\begin{lstlisting}
			using System;
			using System.Collections.Generic;
			using System.Linq;
			
			public class Program
			{
				public static void Main()
				{
					var numbers = new List<int>(new [] {-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8});
			
					var positiveNumbersWithLamdba = numbers.Where(x=> x > 0);
			
					var positiveNumber = numbers.Where(IsPositive);
					
					var positiveTotal = positiveNumber.Aggregate<int>(FoldMethod);
			
			
					var positiveTotalWithAgg = positiveNumbersWithLamdba.Aggregate<int>((agg, n)=> agg += n);
			
					
					Console.WriteLine(positiveTotal);
					
					Console.WriteLine(positiveTotalWithAgg);
					
				}
			
				private static bool IsPositive (int number)
				{
					return number > 0;
				}
				
				public static int FoldMethod (int accumulator, int number){
					return accumulator + number;	
				}
				
			}
		\end{lstlisting}


	\subsection{Func\textless  T\textgreater, Action\textless  T\textgreater, and Predicate\textless  T, bool\textgreater} These are the types behind anonymous methods. 
 {\bf Action \textless  T\textgreater} \space takes at least one argument, and returns nothing. {\bf Func\textless  T\textgreater} always returns something.  {\bf Predicate\textless  T, bool\textgreater} always takes  parameter and returns a bool. 

	\begin{lstlisting}
			using System;
			using System.Collections.Generic;
			using System.Linq;
			
			public class Program
			{
				public static void Main()
				{
					var numbers = new List<int>(new [] {-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8});
			
					var negativeNumbersFilter = new Func<int,bool>(x=> x < 0);
			
					var negativeNumbers = numbers.Where(negativeNumbersFilter);
			
					var negativeNumbersAggregated = negativeNumbers.Aggregate<int>((agg, n)=> agg += n);
			
					Console.WriteLine(negativeNumbersAggregated);
					
				}
			}
	\end{lstlisting}



\section{Classes}
	\subsection{Basic Definition}
	\subsection{Inheritance}
		\subsubsection{Abstract}
		\subsubsection{Virtual}
	\subsection{Polymorphism}
		\subsubsection{Method Overloading}
\section{Structs}
	\subsection{Basic Definition}
	

\section{Namespaces}
	\subsection {Using}
\section{Interfaces}
	\subsection{Syntax} The basic syntax is as follows: 
		\begin{verbatim}
			public interface <Interface-Name> {
				     <Return-Type> <Method-Name> (<Parameter>);
				     <Return-Type> <Property-Name> {get; set;}
				     <Return-Type> <Property-Name> {get; }
				     <Return-Type> <Property-Name> {set;}

				     <Return-Type> <Variable-Name>;
			}
		\end{verbatim}
	\subsection{IEnumerable}
		\subsubsection {yield}

\section{Unmanaged Resources}

\section{LINQ}

\section{Error Handling}
	\subsection{Syntax}  C\# uses the try/catch/finally pattern.
		\begin{lstlisting}
			try{}
			catch (Exception Variable){}
			finally{}
		\end{lstlisting}
	Both {\bf catch} and {\bf finally} are optional, but one of them must exist.  The {\bf finally} block will always execute, even if there is an exception in the {\bf try} block, and if there is no {\bf catch} block, the exception will be thrown once the {\bf finally} block finishes executing.  The {\bf catch} block will only execute if an exception occurs, and the exception will not bubble up the call stack unless rethrown.  
		

\section{Creating Unit Tests}


\end{document}
